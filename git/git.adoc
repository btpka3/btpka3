

##  hook

### pre-commit


[source,shell]
----
----


## gitigore

[source,shell]
----
# 排除任何 层级的 "lib/"
lib/
# 但保留这个 lib 目录
!some/commit/lib/
----


## 开发模式

link:https://bbs.huaweicloud.com/blogs/281789[Git工作流中常见的三种分支策略：GitFlow、GitHubFlow以及GitLabFlow]
默认主干: master

* branch: 分支模式, 多个代码分支自动集成发布
* develop: 自由模式: 可使用任意项目分支进行构建发布

* Git Flow: 项目分支合并到集成分支, 基于集成分支发布
** Master分支: 主干分支，也是正式发布版本的分支，其包含可以部署到生产环境中的代码，通常情况下只允许其他分支将代码合入，不允许向Master分支直接提交代码（对应生产环境）。
*** create from : 无
*** merge from : hotfix,  develop

** Develop分支：开发分支，用来集成测试最新合入的开发成果，包含要发布到下一个Release的代码（对应开发环境）。
*** create from: master, hotfix,
*** merge from : feature

** Feature分支：特性分支，通常从Develop分支拉出，每个新特性的开发对应一个特性分支，用于开发人员提交代码并进行自测。自测完成后，会将Feature分支的代码合并至Develop分支，进入下一个Release。
*** create from: develop
*** merge from : any

** Release分支：发布分支，发布新版本时，基于Develop分支创建，发布完成后，合并到Master和Develop分支（对应集成测试环境）。
*** create from: develop
*** merge from : 无

** Hot fix分支：热修复分支，生产环境发现新Bug时创建的临时分支，问题验证通过后，合并到Master和Develop分支。

[source,plain]
----
maseter ⭕️（v0.1) →→→→→ ⭕️(v0.2) →→→→→→→→→→→→→→→ ⭕️(v1.0)
         ↘            ↗                        ↗
Hotfix    ↘ →→→→→→→→→ ⭕️                      ↗
           ↘            ↘                    ↗
Release     ↘            ↘           ⭕️ →→→ ⭕️
             ↘            ↘        ↗         ↘
Develop       ⭕️ →→→ ⭕️ →→→ ⭕️ →→→ ⭕️ →→→→→→→→ ⭕️
               ↘      ↘          ↗
Feature1        ↘      ⭕️ →→→→ ⭕️
                 ↘
Feature2          ⭕️ →→→ ⭕️ →→→ ⭕️ →→→ ⭕️
----



## 远程仓库复制
[source,shell]
----
# clone 新仓库
git clone git@xxx-host.com:/xxx-group/xxx-repo2.git
cd xxx-repo1

# 强制推送到新远程
git remote add tmp git@xxx-host.com:/xxx-group/xxx-repo1.git
git fetch tmp
git push -f origin tmp/master:master

# 清理
git remote remove tmp
----

== 远程仓库复制:子目录
link:https://grantwinney.com/how-to-move-a-subdirectory-of-one-repo-into-its-own-repository/[Move a subdirectory into its own Git repo, with history]
=== 方式1： 使用 git-filter-repo

== filter-branch
[source,shell]
----
cd ${your_git_repo}
FILTER_BRANCH_SQUELCH_WARNING=1
git filter-branch --subdirectory-filter the-sub-directory-to-keep
----


=== 方式2： 使用三方工具 git-filter-repo

- link:https://github.com/newren/git-filter-repo[git-filter-repo]
- link:https://www.mankier.com/1/git-filter-repo[git-filter-repo - Man Page]

[source,shell]
----
# 前提：已经安装了 git 和 python3
# 下载到 PATH 环境变量中一个子目录，并添加可执行权限
wget -O ${HOME}/git-filter-repo https://raw.githubusercontent.com/newren/git-filter-repo/refs/heads/main/git-filter-repo
chmod u+x ${HOME}/git-filter-repo

cd ${your_git_repo}
# 修改git代码仓库，只保留给定的子目录（含history）
# 可通过 git log, 或gitk 确认
# 然后可以将其推送到新git仓库
git filter-repo --path risk-protocol
----




== sparse-checkout

[source,shell]
----
# 生成 .git/info/sparse-checkout
git sparse-checkout init
# 打开
git config core.sparseCheckout true
# 关闭
git sparse-checkout disable

# 列出当前
git sparse-checkout list
git sparse-checkout set risk-protocol

----


== git gc


[source,shell]
----
# 对本地git仓库 .git/objects 进行清理
# - 压缩对象文件：多个小文件合并成大文件，减少文件系统的碎片化
# - 删除无用的引用
# - 删除 dangling objects : 清楚悬挂对象（没有应用的提交、树、文件）
git gc

# 深度优化，慢
git gc --aggressive

# 删除【今天】以前的所有没有被引用的对象
git gc --prune=now
# 删除【两周】以前的所有没有被引用的对象
git gc --prune=2.weeks.ago
# 根据 `git --no-pager config list | grep gc` 相关配置，自动判断此次是否需要执行 gc
git gc --auto
----


== git grep

[source,shell]
----
# 在当前 HEAD 索引中的文件中查找
git grep xxxSearchStringInFile
# 在当前 HEAD 索引中的 js 文件中查找
git grep xxxSearchStringInFile -- "*.js"

# 在给定 tag 的索引中的文件中查找
git grep xxxSearchStringInFile v1.0
# 在给定 commit 的索引中的文件中查找
git grep xxxSearchStringInFile <xxxCommitHash>

# 显示行号
git grep -n ...
# 忽略大小写
git grep -i ...
# 排除某些内容
git grep -v ...
# 查找内容是正则表达式
git grep -e ...
# 显示匹配行的上下文（前后各10行）
git grep -C 10 ...
----


== git config

具体配置项参考 link:https://git-scm.com/docs/git-config[git-config]

[source,shell]
----
# 列出合并后的最终本地配置
git --no-pager config list
# 列出全局配置
git --no-pager config list --global

# 获取配置项的值
git --no-pager config get user.name
# 设置本地配置项的值
git --no-pager config set user.name btpka3
# 设置全局配置项的值
git --no-pager config set  --global user.name btpka3
----

建议配置

[source,shell]
----
git config set --global user.name    btpka3
git config set --global user.email   btpka3@163.com

# 当输出的内容一个屏幕可以完全显示时不pager，直接全部输出。
# 验证 :
# git log -n 1   # 只显示1个提交历史时，直接输出内容并退出
# git log -n 50  # 显示过多的提交历史时，1屏显示不完，则进行pager，此时仍在less程序内，不退出。
git config set --global core.pager   "less -F"

# 无论内容多少，完全不pager
git config set --global core.pager   cat
----



== git worktree

需要频繁切换分支时，可通过该命令检出多份分支到不同目录来同时工作。

[source,shell]
----
# 列出所有的 worktree
git worktree list
# 清理无效的 worktree
git worktree prune

# 检出一个新的分支到不同的目录，然后多开IDE到该目录下工作，仍可保留当前IDE在当前目录工作
git worktree add ../feature-dir feature-branch

# 开发修复完成后，可以删除临时的 worktree
git worktree remove ../feature-dir
----





== DCO/CLA



[source,shell]
----
# -s 在 commit message 中增加 "Signed-off-by:"
git commit -s -m "xxx commit message"

# 通过rebase 增加 "Signed-off-by:"
git rebase HEAD~1 --signoff
git push —-force-with-lease origin
----


== refSpec

link:https://git-scm.com/book/en/v2/Git-Internals-The-Refspec[10.5 Git Internals - The Refspec]


`.git/config` 中列出了响应的远程仓库，通常远程仓库名称是 "origin",
其中 fetch 值的格式是: `+<src>:<dst>`, 其中前缀 加号是可选的。
加号表示 即便不是 fast-forward 也从更新 reference。
其中 `<src>` 表示的是远程代码仓库本地的 的 reference 前缀
其中 `<dest>` 表示的是本地代码仓库 的 reference 前缀
src,dest 可至多包含一个 `*` 通配符， 且 src/dest 要么同时有，要么同时没有。

[source,plain]
----
[remote "origin"]
        url = git@gitlab.alibaba-inc.com:mtee-bundle/jiugong-container.git
        fetch = +refs/heads/*:refs/remotes/origin/*
----


[source,shell]
----
# add origin 如果不指定分支，默认会fetch所有分支
git remote add origin git@xxx.com:xxx-group/xxx-repo.git

# 列出所有本地仓库的 reference
git show-ref

# 以下三个命令等同，git 会将他们都扩展成 `refs/remotes/origin/master`
git log origin/master
git log remotes/origin/master
git log refs/remotes/origin/master

# tag 的 完整格式是 `refs/tags/<tag>`

# 如果想只fetch 一个分支，可以用以下格式:
# 将远程代码仓库的 master 分支 fetch 到本地的 refs/remotes/origin/master
git fetch origin master:refs/remotes/origin/master

# 推送本地 src 到远程仓库的 dst
git push <repository> <src>:<dst>
# 删除远程分支，因为未指定本地分支
git push <repository> :<dst>
----




== bisect

二分查找法定位 哪个commit 引入了bug

[source,shell]
----
git bisect start
git bisect start -- src/

# 标记 哪个commit是有问题的
git bisect bad        # 标记当前 HEAD
git bisect bad <bad-commit-hash>

git bisect good

git bisect reset
git bisect skip        # 跳过当前提交

git bisect run ./test-script.sh
----


== log
定位首次引入，删除某个字符串的commit

[source,shell]
----
# 基础搜索（仅显示commit信息）
git log -S"target_string" -- path/to/file
# 显示详情（详细显示commit diff）
git log -S"target_string" -p -- path/to/file
# 处理重命名/移动
git log --follow -S"target_string" -- path/to/file
----


== 大文件存储
* Git-LFS: git 官方的大文件解决方案，但发展缓慢，配置复杂、失败时需整体重新上传。
* DVC : AI社区的一个版本管理方案，支持 pielien,metrics 等AI相关工作量和度量能力，但需分别使用 git,dvc命令，操作复杂。

